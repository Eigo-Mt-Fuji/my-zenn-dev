---
title: "[Rust]今日の学び2022-08-16 - ボックス化はどのような場合に行うのか(初歩的意訳と練習)"
emoji: "🔥"
type: "tech" 
topics: ["Rust"]
published: true
---

これは個人的な練習のノートです。
間違っていた場合はごめんなさい。
御手柔らかにお願いします。アドバイスを貰えると喜びます。

## はじめに

今年中に、手足のようにRustを使える自信をつけたくて
Effective Rustを1章ずつ読んでいく目標を立てました。

ただ、それだけだと飽きてしまう恐れがある。
不安な基本部分を取り出して咀嚼したり練習をしています。
ここでは、その備忘録を公開しようと思いますしようと思います。

今日はボックス化について

- ボックス化はどのような場合に行うのか
  - リファレンスのユースケース(英文)を意訳する
- 練習: 整数型を使ったボックス化
  - 簡単なコードを書きながら理解する

をやっていきます。

## 参考情報

- [web.mit.edu - The Rust Programming Language(First Edition) - Effective Rust](https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/effective-rust.html)
- [doc.rust-jp.rs - rust-by-example-ja/scope/borrow - 借用](https://doc.rust-jp.rs/rust-by-example-ja/scope/borrow.html)
- [doc.rust-lang.org/book/ch15-01-box.html - Using Box<T> to Point to Data on the Heap](https://doc.rust-lang.org/book/ch15-01-box.html#using-boxt-to-point-to-data-on-the-heap)

## 本題

### ボックス化はどのような場合に行うのか

- [Rust by example 日本語版のBox, スタックとヒープ](https://doc.rust-jp.rs/rust-by-example-ja/std/box.html)を読んだ
  - ボックス化は、いわゆるスマートポインタ。ボックス化することで意図的にヒープ上に割り当てることができるということは理解。

- どのようなケースでボックス化を意識して行うべき（あるいは行わないべき）かを知りたい
  - 基本的には、ヒープ上の領域確保は、スタックと比べると重たい処理。ボックス化(要するに、ヒープ確保)をすると、スタックの高速な領域確保の利点が失われることになる。
    - 意図的にヒープ上の領域確保を考えるべきケースを除いて、やらないほうがよさそうという認識している。
  - その上で、どのようなケースでボックス化を意識して行うべき（あるいは行わないべき）かを知りたい。

- doc.rust-lang.org(英語版)の説明があった。愚直に翻訳することにした。
  - [doc.rust-lang.org/book/ch15-01-box.html - Using Box<T> to Point to Data on the Heap](https://doc.rust-lang.org/book/ch15-01-box.html#using-boxt-to-point-to-data-on-the-heap)
    - 3つのユースケースが紹介されていた。抜粋しつつ個人的に意訳した。
        - Case1. When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so
            - 個人的意訳: 大規模データを扱っており、かつ、所有権の移動が発生するようなソースコードで、データのコピーが発生しないことを確実に保証する目的でボックス化を行う
        - Case2. When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size
            - 個人的意訳: コンパイル時にサイズがわからない型を扱う場合（かつ、その型の値の正確なサイズが必要なケース）
        - Case3. When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type
            - 個人的意訳: 自分で値の所有権を保持したい場合で、かつ、その値の具体的な型よりもその値の型がなんらかのtrait(性質)が実装したものであることの方を重視したい場合
    - 感想
      - Case1, Case2はなんとなくわかる。Case3はどの程度発生するケースなのか疑問が残ったままだ(実践が必要)
        - 自分で値の所有権を保持したい場合はわからないが、traitで抽象化して扱うことはそれなりにありそう(意外とよく使うのか?)
          - 参考にできるコードを探して読んでみようと思う。

### [練習: 整数型を使ったボックス化](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn%20awesome_borrow_with_box(int_on_box_borrow%3A%20%26Box%3Ci32%3E)%20-%3E%20bool%20%7B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A6%E3%83%88%E3%81%99%E3%82%8B%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8B%20%E7%90%86%E7%94%B1%3A%20expected%20struct%20%60Box%60%2C%20found%20integer%0A%20%20%20%20%2F%2F%20*int_on_box_borrow%20%3D%20101%3B%0A%0A%20%20%20%20%2F%2F%20%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A6%E3%83%88%E3%81%99%E3%82%8B%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8B%20%E7%90%86%E7%94%B1%3A%20cannot%20assign%20to%20%60**int_on_box_borrow%60%2C%20which%20is%20behind%20a%20%60%26%60%20reference%0A%20%20%20%20%2F%2F%20**int_on_box_borrow%20%3D%20101%3B%0A%0A%20%20%20%20println!(%22int%20with%20boxed%3A%20borrow%20%3D%20%7B%7D%22%2C%20int_on_box_borrow)%3B%0A%20%20%20%20true%0A%7D%0A%0Afn%20main()%20%7B%0A%0A%20%20%20%20%2F%2F%20%E9%80%9A%E5%B8%B8%E3%81%AEinteger(%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E4%B8%8A%E3%81%AB%E6%A0%BC%E7%B4%8D%E3%81%95%E3%82%8C%E3%82%8B)%0A%20%20%20%20let%20int_on_stack%3A%20i32%20%3D%20100%3B%0A%0A%20%20%20%20%2F%2F%20%E5%A4%89%E6%95%B0int_on_stack_copy%E3%81%AB%E3%82%B3%E3%83%94%E3%83%BC%20%E2%80%BB%E5%80%A4%E3%81%AE%E5%A4%89%E6%9B%B4%E7%A2%BA%E8%AA%8D%E3%81%AE%E3%81%9F%E3%82%81mut%E4%BF%AE%E9%A3%BE%E5%AD%90%E3%82%92%E4%BB%98%E4%B8%8E)%0A%20%20%20%20let%20mut%20int_on_stack_copy%20%3D%20int_on_stack%3B%0A%20%20%20%20println!(%22int%20on%20stack%3A%20copy%20is%20ok.%20original%20%3D%20%7B%7D%2C%20copy%20%3D%20%7B%7D.%22%2C%20int_on_stack%2C%20int_on_stack_copy)%3B%0A%20%20%20%20println!(%22int%20on%20stack%3A%20change%20value%20of%20int_on_stack_copy(from%20100%20to%2050).%22)%3B%0A%20%20%20%20%2F%2F%20%0A%20%20%20%20int_on_stack_copy%20%3D%2050%3B%0A%20%20%20%20println!(%22int%20on%20stack%3A%20copy%20is%20stored%20as%20different%20on%20stack.%20original%20%3D%20%7B%7D%2C%20copy%20%3D%20%7B%7D.%22%2C%20int_on_stack%2C%20int_on_stack_copy)%3B%0A%0A%20%20%20%20let%20mut%20int_on_box%3A%20Box%3Ci32%3E%20%3D%20std%3A%3Aboxed%3A%3ABox%3A%3Anew(100)%3B%0A%0A%20%20%20%20%2F%2F%20box%E5%8C%96%E3%81%97%E3%81%9F%E5%80%A4%E3%81%AE%E5%8F%82%E7%85%A7%E3%83%BB%E5%80%9F%E7%94%A8%E3%81%AE%E5%8B%95%E4%BD%9C%E3%82%92%E7%A2%BA%E8%AA%8D%0A%20%20%20%20let%20int_on_box_borrow_local%20%3D%20%26int_on_box%3B%0A%0A%20%20%20%20%2F%2F%20%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A6%E3%83%88%E3%81%99%E3%82%8B%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8B%20%E7%90%86%E7%94%B1%3A%20cannot%20assign%20to%20%60*int_on_box%60%20because%20it%20is%20borrowed%20(L29%E3%81%AE%E5%8F%82%E7%85%A7%E3%81%A7%E5%80%A4%E3%81%8C%E5%80%9F%E7%94%A8%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E2%86%92%E5%85%83%E3%81%AE%E5%A4%89%E6%95%B0int_on_box%E3%81%AB%E6%96%B0%E3%81%97%E3%81%84%E5%80%A4%E3%82%92%E4%BB%A3%E5%85%A5%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84)%0A%20%20%20%20%2F%2F%20*int_on_box%20%3D%20102%3B%0A%0A%20%20%20%20%2F%2F%20%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A6%E3%83%88%E3%81%99%E3%82%8B%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8B%20%E7%90%86%E7%94%B1%3A%20expected%20struct%20%60Box%60%2C%20found%20integer(int_on_box_borrow_local%E3%81%AF%E3%80%81i32%E3%82%92box%E5%8C%96%E3%81%97%E3%81%9F%E5%80%A4%E3%81%AE%E5%8F%82%E7%85%A7%E3%81%A0%E3%81%8B%E3%82%89%E3%80%81*int_on_box_borrow_local%E3%81%A8%E6%9B%B8%E3%81%8F%E3%81%A8%E3%81%93%E3%82%8C%E3%81%AF%20struct%20Box%E5%9E%8B%E3%81%8C%E8%BF%94%E3%81%95%E3%82%8C%E3%82%8B)%0A%20%20%20%20%2F%2F%20*int_on_box_borrow_local%20%3D%20102%3B%0A%0A%20%20%20%20%2F%2F%20%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A6%E3%83%88%E3%81%99%E3%82%8B%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8B%20%E7%90%86%E7%94%B1%3A%20cannot%20assign%20to%20%60**int_on_box_borrow_local%60%2C%20which%20is%20behind%20a%20%60%26%60%20reference%0A%20%20%20%20%2F%2F%20**int_on_box_borrow_local%20%3D%20102%3B%0A%20%20%20%20%0A%20%20%20%20println!(%22int%20with%20boxed%3A%20int_on_box_borrow_local%3D%7B%7D%2C%20original%20%3D%20%7B%7D%22%2C%20int_on_box_borrow_local%2C%20int_on_box)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20%E9%96%A2%E6%95%B0%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E3%82%92%E9%80%9A%E3%81%98%E3%81%A6%E5%80%A4%E3%81%AE%E5%80%9F%E7%94%A8%E3%82%92%E8%A9%A6%E3%81%99%0A%20%20%20%20awesome_borrow_with_box(%26int_on_box)%3B%0A%20%20%20%20%2F%2F%20L43%E3%81%AE%E9%96%A2%E6%95%B0%E5%AE%9F%E8%A1%8C%E3%81%8C%E7%B5%82%E4%BA%86%E3%81%97%E5%80%9F%E7%94%A8%E5%80%A4%E3%81%AE%E2%86%92%E5%85%83%E3%81%AE%E5%A4%89%E6%95%B0int_on_box%E3%81%AB%E6%96%B0%E3%81%97%E3%81%84%E5%80%A4%E3%82%92%E4%BB%A3%E5%85%A5%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84)%0A%20%20%20%20*int_on_box%20%3D%20103%3B%0A%20%20%20%20println!(%22int%20with%20boxed%3A%20original%20%3D%20%7B%7D%22%2C%20int_on_box)%3B%0A%0A%20%20%20%20let%20int_on_box_borrow_mut%20%3D%20%26mut%20int_on_box%3B%0A%20%20%20%20**int_on_box_borrow_mut%20%3D%20104%3B%0A%0A%20%20%20%20%2F%2F%20%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A6%E3%83%88%E3%81%99%E3%82%8B%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8B%20%E7%90%86%E7%94%B1%3A%20error%5BE0502%5D%3A%20cannot%20borrow%20%60int_on_box%60%20as%20immutable%20because%20it%20is%20also%20borrowed%20as%20mutable%0A%20%20%20%20%2F%2F%20println!(%22int%20with%20boxed%3A%20int_on_box_borrow_mut%3D%7B%7D%2C%20original%20%3D%20%7B%7D%22%2C%20int_on_box_borrow_mut%2C%20int_on_box)%3B%0A%0A%20%20%20%20%2F%2F%20%E4%BB%A5%E4%B8%8B%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A6%E3%83%88%E3%81%99%E3%82%8B%E3%81%A8%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AB%E3%81%AA%E3%82%8B%20%E7%90%86%E7%94%B1%3A%20error%5BE0499%5D%3A%20cannot%20borrow%20%60int_on_box%60%20as%20mutable%20more%20than%20once%20at%20a%20time%0A%20%20%20%20%2F%2F%20println!(%22int%20with%20boxed%3A%20int_on_box_borrow_mut%3D%7B%7D%2C%20original%20%3D%20%7B%7D%22%2C%20int_on_box_borrow_mut%2C%20%26mut%20int_on_box)%3B%0A%0A%20%20%20%20println!(%22int%20with%20boxed%3A%20int_on_box%3D%7B%7D%22%2C%20int_on_box)%3B%0A%7D%0A)

- 愚直に、i32型のボックス化を練習してみた。
  - こんなコードを書くことはないだろうが、あくまで練習。
    - Box<T>した後の参照・借用、その後の値の書き換え。エラーが発生するポイントを、教科書的に確認していく作業。
    - ボックス化した後を参照してから中身を更新するコードを書くと、C言語の2重ポインタに似た感じになるな。

```rust
fn awesome_borrow_with_box(int_on_box_borrow: &Box<i32>) -> bool {
    
    // 以下のコードはコメントアウトするとエラーになる 理由: expected struct `Box`, found integer
    // *int_on_box_borrow = 101;

    // 以下のコードはコメントアウトするとエラーになる 理由: cannot assign to `**int_on_box_borrow`, which is behind a `&` reference
    // **int_on_box_borrow = 101;

    println!("int with boxed: borrow = {}", int_on_box_borrow);
    true
}

fn main() {

    // 通常のinteger(スタック上に格納される)
    let int_on_stack: i32 = 100;

    // 変数int_on_stack_copyにコピー ※値の変更確認のためmut修飾子を付与)
    let mut int_on_stack_copy = int_on_stack;
    println!("int on stack: copy is ok. original = {}, copy = {}.", int_on_stack, int_on_stack_copy);
    println!("int on stack: change value of int_on_stack_copy(from 100 to 50).");
    // 
    int_on_stack_copy = 50;
    println!("int on stack: copy is stored as different on stack. original = {}, copy = {}.", int_on_stack, int_on_stack_copy);

    let mut int_on_box: Box<i32> = std::boxed::Box::new(100);

    // box化した値の参照・借用の動作を確認
    let int_on_box_borrow_local = &int_on_box;

    // 以下のコードはコメントアウトするとエラーになる 理由: cannot assign to `*int_on_box` because it is borrowed (L29の参照で値が借用されている→元の変数int_on_boxに新しい値を代入できない)
    // *int_on_box = 102;

    // 以下のコードはコメントアウトするとエラーになる 理由: expected struct `Box`, found integer(int_on_box_borrow_localは、i32をbox化した値の参照だから、*int_on_box_borrow_localと書くとこれは struct Box型が返される)
    // *int_on_box_borrow_local = 102;

    // 以下のコードはコメントアウトするとエラーになる 理由: cannot assign to `**int_on_box_borrow_local`, which is behind a `&` reference
    // **int_on_box_borrow_local = 102;
    
    println!("int with boxed: int_on_box_borrow_local={}, original = {}", int_on_box_borrow_local, int_on_box);
    
    // 関数の呼び出しを通じて値の借用を試す
    awesome_borrow_with_box(&int_on_box);
    // L43の関数実行が終了し借用値の→元の変数int_on_boxに新しい値を代入できない)
    *int_on_box = 103;
    println!("int with boxed: original = {}", int_on_box);

    let int_on_box_borrow_mut = &mut int_on_box;
    **int_on_box_borrow_mut = 104;

    // 以下のコードはコメントアウトするとエラーになる 理由: error[E0502]: cannot borrow `int_on_box` as immutable because it is also borrowed as mutable
    // println!("int with boxed: int_on_box_borrow_mut={}, original = {}", int_on_box_borrow_mut, int_on_box);

    // 以下のコードはコメントアウトするとエラーになる 理由: error[E0499]: cannot borrow `int_on_box` as mutable more than once at a time
    // println!("int with boxed: int_on_box_borrow_mut={}, original = {}", int_on_box_borrow_mut, &mut int_on_box);

    println!("int with boxed: int_on_box={}", int_on_box);
}
```

- 実行結果

```
int on stack: copy is ok. original = 100, copy = 100.
int on stack: change value of int_on_stack_copy(from 100 to 50).
int on stack: copy is stored as different on stack. original = 100, copy = 50.
int with boxed: int_on_box_borrow_local=100, original = 100
int with boxed: borrow = 100
int with boxed: original = 103
int with boxed: int_on_box=104
```

## おわりに

所有権が難しい。
借りられてる変数を一瞬忘れてprintln!しようとすると不意にエラーになって、借用、むずかしい。。という気持ちになった。



Rustの満足行く開発ができるようになるまで
ちょっとずつやっていきます。
